{"ast":null,"code":"import { decode as base64url } from '../../runtime/base64url.js';\nimport verify from '../../runtime/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder } from '../../lib/buffer_utils.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nexport async function flattenedVerify(jws, key, options) {\n  if (!isObject(jws)) {\n    throw new JWSInvalid('Flattened JWS must be an object');\n  }\n  if (jws.protected === undefined && jws.header === undefined) {\n    throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n  }\n  if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n    throw new JWSInvalid('JWS Protected Header incorrect type');\n  }\n  if (jws.payload === undefined) {\n    throw new JWSInvalid('JWS Payload missing');\n  }\n  if (typeof jws.signature !== 'string') {\n    throw new JWSInvalid('JWS Signature missing or incorrect type');\n  }\n  if (jws.header !== undefined && !isObject(jws.header)) {\n    throw new JWSInvalid('JWS Unprotected Header incorrect type');\n  }\n  let parsedProt = {};\n  if (jws.protected) {\n    try {\n      const protectedHeader = base64url(jws.protected);\n      parsedProt = JSON.parse(decoder.decode(protectedHeader));\n    } catch {\n      throw new JWSInvalid('JWS Protected Header is invalid');\n    }\n  }\n  if (!isDisjoint(parsedProt, jws.header)) {\n    throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n  }\n  const joseHeader = {\n    ...parsedProt,\n    ...jws.header\n  };\n  const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, parsedProt, joseHeader);\n  let b64 = true;\n  if (extensions.has('b64')) {\n    b64 = parsedProt.b64;\n    if (typeof b64 !== 'boolean') {\n      throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n    }\n  }\n  const {\n    alg\n  } = joseHeader;\n  if (typeof alg !== 'string' || !alg) {\n    throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n  }\n  const algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n  if (algorithms && !algorithms.has(alg)) {\n    throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter value not allowed');\n  }\n  if (b64) {\n    if (typeof jws.payload !== 'string') {\n      throw new JWSInvalid('JWS Payload must be a string');\n    }\n  } else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n    throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n  }\n  let resolvedKey = false;\n  if (typeof key === 'function') {\n    key = await key(parsedProt, jws);\n    resolvedKey = true;\n  }\n  checkKeyType(alg, key, 'verify');\n  const data = concat(encoder.encode(jws.protected ?? ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n  let signature;\n  try {\n    signature = base64url(jws.signature);\n  } catch {\n    throw new JWSInvalid('Failed to base64url decode the signature');\n  }\n  const verified = await verify(alg, key, signature, data);\n  if (!verified) {\n    throw new JWSSignatureVerificationFailed();\n  }\n  let payload;\n  if (b64) {\n    try {\n      payload = base64url(jws.payload);\n    } catch {\n      throw new JWSInvalid('Failed to base64url decode the payload');\n    }\n  } else if (typeof jws.payload === 'string') {\n    payload = encoder.encode(jws.payload);\n  } else {\n    payload = jws.payload;\n  }\n  const result = {\n    payload\n  };\n  if (jws.protected !== undefined) {\n    result.protectedHeader = parsedProt;\n  }\n  if (jws.header !== undefined) {\n    result.unprotectedHeader = jws.header;\n  }\n  if (resolvedKey) {\n    return {\n      ...result,\n      key\n    };\n  }\n  return result;\n}","map":{"version":3,"names":["decode","base64url","verify","JOSEAlgNotAllowed","JWSInvalid","JWSSignatureVerificationFailed","concat","encoder","decoder","isDisjoint","isObject","checkKeyType","validateCrit","validateAlgorithms","flattenedVerify","jws","key","options","protected","undefined","header","payload","signature","parsedProt","protectedHeader","JSON","parse","joseHeader","extensions","Map","crit","b64","has","alg","algorithms","Uint8Array","resolvedKey","data","encode","verified","result","unprotectedHeader"],"sources":["C:/Users/denis/VSCode_projects/Pochinim.ru/client/pochinim.ru/node_modules/jose/dist/browser/jws/flattened/verify.js"],"sourcesContent":["import { decode as base64url } from '../../runtime/base64url.js';\nimport verify from '../../runtime/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder } from '../../lib/buffer_utils.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nexport async function flattenedVerify(jws, key, options) {\n    if (!isObject(jws)) {\n        throw new JWSInvalid('Flattened JWS must be an object');\n    }\n    if (jws.protected === undefined && jws.header === undefined) {\n        throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n        throw new JWSInvalid('JWS Protected Header incorrect type');\n    }\n    if (jws.payload === undefined) {\n        throw new JWSInvalid('JWS Payload missing');\n    }\n    if (typeof jws.signature !== 'string') {\n        throw new JWSInvalid('JWS Signature missing or incorrect type');\n    }\n    if (jws.header !== undefined && !isObject(jws.header)) {\n        throw new JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n    let parsedProt = {};\n    if (jws.protected) {\n        try {\n            const protectedHeader = base64url(jws.protected);\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch {\n            throw new JWSInvalid('JWS Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jws.header)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header,\n    };\n    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') {\n            throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n    }\n    const { alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n    if (algorithms && !algorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter value not allowed');\n    }\n    if (b64) {\n        if (typeof jws.payload !== 'string') {\n            throw new JWSInvalid('JWS Payload must be a string');\n        }\n    }\n    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n        resolvedKey = true;\n    }\n    checkKeyType(alg, key, 'verify');\n    const data = concat(encoder.encode(jws.protected ?? ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n    let signature;\n    try {\n        signature = base64url(jws.signature);\n    }\n    catch {\n        throw new JWSInvalid('Failed to base64url decode the signature');\n    }\n    const verified = await verify(alg, key, signature, data);\n    if (!verified) {\n        throw new JWSSignatureVerificationFailed();\n    }\n    let payload;\n    if (b64) {\n        try {\n            payload = base64url(jws.payload);\n        }\n        catch {\n            throw new JWSInvalid('Failed to base64url decode the payload');\n        }\n    }\n    else if (typeof jws.payload === 'string') {\n        payload = encoder.encode(jws.payload);\n    }\n    else {\n        payload = jws.payload;\n    }\n    const result = { payload };\n    if (jws.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jws.header !== undefined) {\n        result.unprotectedHeader = jws.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}